## HTML 基础

### 1.H5 的语义化标签以及语义化作用（1）

### 2.Web Worker 和 Web Socket(1)

### 3.HTML5 新特性 （1）

---

## CSS 基础

### 1.元素水平垂直居中(3)

    五种方法:
    --- 绝对定位（left:50%,top:50%）+transform:translate（-50%，-50%）--兼容性问题
    --- 绝对定位(left:0,right:0,top:0,bottom:0,margin:0 auto)--盒子有宽高
    ---绝对定位(left:50%,top:50%)+margin负值--盒子宽度已知
    ---flex align-item:center justify-content:center--兼容性问题
    ---grid justify-content:center  align-content: center --兼容性问题

### 2.两栏布局(3)

    五种方法:
    --- 浮动+margin(左侧：float:left,width:200px,右侧:margin-left:200px;width:auto)
    --- 浮动+overflow（左侧：float:left,width:200px,右侧:overflow:hidden）
    --- 父元素相对定位，左侧绝对定位+右侧margin值
    --- 父元素相对定位, 右侧绝对定位，且设置left值
    --- 设置父元素flex,(左侧:width:200px;右侧:flex:1)

### 3.三栏布局(2)

    五种方法:
    --- 浮动+margin（左右两侧向对应方向浮动，中间设置margin值）
    --- 左右绝对定位+中间设置margin值
    --- 设置父元素flex,左右固定，中间设置flex：1
    --- 圣杯布局（浮动+负边距(margin),父元素设置左右padding,子元素设置左浮动，中间一列最前面，通过margin赋值将后两列移动到上一行）
    --- 双飞翼布局(浮动+外负边距，设置中间一列子元素的margin)

### 4.CSS 引入方式 （2）

    ---行内样式
    ---内部样式表
    ---外部样式表（link、import）

### 5.样式优先级（2）

    --- id选择器（100）

    --- 类选择器 （10）
    --- 属性选择器
    --- 伪类选择器

    --- 标签选择器 （1）
    --- 伪元素选择器

    --- 相邻兄弟选择器 （0）
    --- 子代选择器
    --- 后代选择器
    --- 通配选择器

### 6.盒模型（2）

### 7.display 属性值以及区别 （1）

### 8.position 属性值以及区别（1）

### 9.flex（2）

### 10.自适应布局（1）

    ---rem+媒体查询
    ---vw实现
    ---rem+vw+flexible实现

### 11.px、em、rem、vw、vh、rpx 的区别（2）

### 12.less 和 Sass（1）

### 13.css 实现轮播图（1）

    ---可以通过使用js控制每张图片的相对位置来实现，在第一张图片之前和最后一张图片之后分别补充最后一张和第一张图片，在最后一张切换到第一张时将容器的left设置为0，实现无缝轮播
    ---通过CSS的动画实现，控制z-index和opacity，同时给每张图设置延时显示时间
    ---vue可以利用v-show和transition实现

### 14.如何触发硬件加速（1）

    --- transform
    --- opacity
    --- filters
    --- will-change

### 15.link 和 import 标签的区别（1）

### 16.如何清除浮动（1）

    --- 额外标签:clear:both
    --- overflow:hidden
    --- 使用伪类元素:after

### 17.什么是 BFC (1)

    BFC特性
    ---同一个BFC下margin会重叠
    ---计算BFC高度时会算上浮动元素
    ---BFC不会影响到外部元素
    ---BFC内部元素是垂直排列的
    ---BFC区域不会与float元素重叠
    如何创建BFC
    ---position设为absolute或者fixed
    ---float不为none
    ---overflow设置为hidden
    ---display设置为inline-block或者inline-table或flex

### 18.doctype 标签和 meta 标签(1)

### 19.first-of-type 和 first-child 有什么区别(1)

    ---first-of-type 匹配的是从第一个子元素开始数，匹配到的那个的第一个元素

### 20. 常见的替换元素和非替换元素？（1）

    ---标签的属性可以改变标签的显示方式就是替换元素（input、img、iframe）

### 21.行内元素和块级元素（1）

### 22.什么是 requestAnimationFrame （1）

### 23.什么是回流和重绘（1）

## JS 基础

### 1. JS 继承类型（4）

    6种方法：
    --- 原型链继承
    --- 借用构造函数继承
    --- 组合继承
    --- 原型式继承
    --- 寄生继承
    --- 寄生组合继承(extend)

### 2. JS 的基本数据类型（2）

### 3. 原始值和引用值类型及区别(2)

    区别：
    --1.存储类型不同--栈和堆（原始类型占据空间固定）
    --2.赋值方式
    --3.比较方式（原始类型是值比较、引用类型是地址比较）

### 4.判断数据类型（3）

    ---1.调用typeof
    ---2.使用instanceOf（构造函数的prototype属性是否出现在某个实例对象的原型链上，不能判断null和undefined）
    ---3.constructor
    ---4.object.prototype.toString.call

### 5.数组和类数组的区别及转换（2）

    ---1.通过call调用数组的slice方法
    ---2.通过call调用数组的map方法
    ---3.Array.from
    ---4.扩展预算符

### 6.常见的数组 api（2）

    map、reduce、forEach、flat、slice、push、pop、shift、unshift、splice、concat、every、fill、filter、findIndex、indexOf、join、keys、reverse

### 7.bind、call、apply 的区别，手动实现（2）

    bind创建一个新函数、新的函数的this指定为bind的第一个参数，其余参数作为新函数的参数，以参数列表的形式传递参数

### 8.===和==区别（2）

### 9.深拷贝与浅拷贝 (2)

    --浅拷贝(Obejct.assign(),扩展运算符)
    --深拷贝(解决对象嵌套问题)

### 10.防抖和节流（2）

### 11.作用域和作用域链(3)
    ---作用域：变量和函数可使用范围

### 12.JS 的垃圾回收机制(3)

### 13.addEventListener 和 onClick 区别(1)

    ---onClick:绑定多个事件，只有最后一个事件会被触发,之前的被覆盖，该事件只在冒泡阶段捕获
    ---addEventListener:绑定多个事件，触发多次。根据参数，可在冒泡和捕获阶段触发，对任何dom元素都生效，不只是html元素

### 14.JavaScript 中的事件循环机制，宏任务与微任务(2)

### 15.跨域、同源策略以及跨域解决方案(2)

    --- cors(缺点:会产生预检请求)
    --- jsnop
    --- document.domain（二级域名必须相同，协议和端口一致,否则无法使用）
    --- postMessage
    --- nginx反向代理
    --- node中间件代理（devServer:proxy）
    --- localtion.hash+iframe跨域
    --- window.name+iframe跨域
    --- websocket

### 16.说下浏览器对象(BOM)有哪些（1）

    ---navigator
    ---window
    ---localtion
    ---history
    ---screen

### 17.原型和原型链（2）

### 18.闭包及其作用（2）
    闭包的应用
    ---单例模式
    ---for循环里面保存i
    ---防抖、节流、柯里化

### 19.如何正确判断 this（2）

    ---函数调用
    ---方法调用
    ---构造器调用
    ---call、apply、bind调用

### 20.什么是 dom 事件流？什么是事件委托？(1)

### 21.defer 和 async 都表示什么 (1)

### 22.js 性能优化的方式（1）

    ---垃圾回收
    ---闭包中对象的清除
    ---防抖节流
    ---分批加载
    ---事件委托
    ---尾调用优化
    ---少用with
    ---requestAnimationFrame
    ---defer和async
    ---cdn

### 23.常用的设计模式(1)

    ---单例模式
    ---工厂模式
    ---构造函数模式
    ---发布订阅模式
    ---迭代器模式
    ---代理模式
    ---策略模式

### 24.事件冒泡和事件捕获有什么区别？（1）

### 25.localstorage 存满了怎么办?（1）

    ---划分域名
    ---跨页面传数据
    ---兜底方案:调用别人的存储

### 26.js 模块包装格式（1）

    ---commonjs（同步运行，不适合前端）
    ---amd(异步运行)
    ---cmd(异步运行，seajs规范)

### 27.exports 和 module.exports 有什么区别？(1)

    ---导出方式不一样
    ----exports.xxx='xxx'
    ----module.export = {}
    ---exports是module.exports的引用，两个指向的是用一个地址，而require能看到的只有module.exports

### 28.为什么要使用模块化(1)

    ---防止命名冲突
    ---更好的分离、按需加载
    ---更好的复用和可维护性

### 29.变量和函数怎么进行提升的？优先级是怎么样的（1）

### 30.Generator 是怎么样使用的以及各个阶段的变化如何 (1)

    状态变化：

    ---每当执行到yield属性的时候，都会返回一个对象,这时候生成器处于一个非阻塞的挂起状态
    ---调用迭代器的next方法的时候，生成器又从挂起状态改为执行状态，继续上一次的执行位置执行
    ---直到遇到下一次yield依次循环,直到代码没有yield了，就会返回一个结果对象done为true，value为undefined

### 31.如何实现异步编程(1)

### 32.js 为什么是单线程的（1）

### 33.内存泄漏(1)

### 34.什么是执行栈，什么是执行上下文（1）

### 35.字面量new出来的对象和 Object.create(null)创建出来的对象有什么区别（1）
    ---字面量和new创建出来的对象会继承Object的方法和属性，他们的隐式原型会指向Object的显式原型
    ---Object.create(null)创建出来的对象原型为null，作为原型链的顶端，自然也没有继承Object的方法和属性

### 36.为什么typeof null是Object（1）

### 37.那既然0.1不是0.1了，为什么在console.log(0.1)的时候还是0.1呢?
    ---在console.log的时候会二进制转换为十进制，十进制再会转为字符串的形式，在转换的过程中发生了取近似值，所以打印出来的是一个近似值的字符串

### 38.那为什么0.2+0.3=0.5呢?（1）
    0.2 和0.3分别转换为二进制进行计算：在内存中，它们的尾数位都是等于52位的，而他们相加必定大于52位，而他们相加又恰巧前52位尾数都是0，截取后，恰好就是0.5

### 39.在JS中为什么0.2+0.1>0.3?（1）
    因为在JS中，浮点数是使用64位固定长度来表示的，其中的1位表示符号位，11位用来表示指数位，剩下的52位尾数位，由于只有52位表示尾数位，而0.1转为二进制是一个无限循环数，由于只能存储52位尾数位，所以会出现精度缺失，把它存到内存中再取出来转换成十进制就不是原来的0.1了
---

## ES6

### 1.ES6 有哪些新特性（1）

    ---模板字符串、扩展运算符、startWith、endWith、reapted、Promise、Reflect、块级作用域(let、const、var)、解构赋值、箭头函数、set和map、Proxy

### 2.let、const、var 的区别（3）

### 3.解构赋值(1)

### 4.箭头函数和普通函数的区别（this 指向），箭头函数可以被当作构造函数 new 吗？(3)

    ---箭头函数比普通函数简洁
    ---箭头函数没有自己的this，箭头函数没有Prototype
    ---箭头函数继承来的this永远不会变，call、bind、apply没有办法修改箭头函数的指向，
    ---箭头函数不能作为构造函数调用
    ---箭头函数没有自己的arguments
    ---箭头函数不能作为genarator函数，不能使用yield关键字

### 5.Symbol (1)

### 6.Set 和 Map 数据结构 (1)

### 7.Proxy(1)

### 8.Promise(2)

### 9.for、forEach、for in、for of 比较(1)

    ---for in 是为对象而设计（会遍历出原型链对象上的属性，属性名出现时不确定的）

### 10. async 和 await (1)

### 11.ES6 模块加载和 CommonJS 加载的原理、区别(3)

    ---CommonJS输出的是值的拷贝，ES Module输出的是值的引用，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const
    ---CommonJS是运行时加载（module.exports），ES Module是编译时输出接口
    ---CommonJS的require（）是同步加载模块，ESModule的import是异步加载模块，静态编译时加载，有独立的模块依赖解析
    ---CommonJS模块的顶层this指向当前模块，ES6模块中，顶层this指向undefined

---

## Http 协议和计算机网络

### 1.tcp 和 udp(2)

    ---是否连接 (udp无连接
    、tcp面向连接)
    ---是否可靠（udp不可靠传输，不使用流量控制和拥塞控制、tcp可靠传输）
    ---连接对象个数（udp一对一、一对多、多对一、多对多、tcp一对一）
    ---传输方式（udp面向报文、tcp面向字节流）
    ---首部开销（udp首部开销小，8字节、tcp首部最小20字节，最大60字节）
    ---使用场景 （udp实时应用（IP电话、视频会议、直播等）tcp适用于要求可靠传输的应用，比如文件传输）

### 2.TCP 三次握手，两次行不行，四次行不行，四次挥手？(2)

    ---三次握手:
    ----1.客户端先向服务端发起一个SYN包，进入SYN_SENT状态
    ----2.服务端收到SYN后，给客户端返回一个ACK+SYN包，表示已收到SYN，并进入SYN_RECEIVE状态，
    ----3.最后客户端再向服务端发送一个ACK包表示确认，双方进入establish状态。

    ---四次挥手:
    ----1.客户端向服务端发送一个FIN包，进入FIN_WAIT1状态
    ----2.服务端收到后，向客户端发送ACK确认包，进入CLOSE_WAIT状态
    ----3.然后客户端收到ACK包后进入FIN_WAIT2状态
    ----4.服务端再把自己剩余没传完的数据发送给客户端，发送完毕后在发送一个FIN+ACK包，进入LAST_ACK（最后确认）状态----5.客户端收到FIN+ACK包后，再向服务端发送ACK包，在等待两个周期后在关闭连接

### 3.HTTP 请求方法有哪些、put 和 post 的区别（1）

    ---put是幂等操作，而post不是

### 4.get 和 post 的区别（2）

    --- 后退和刷新（get是无害的，post数据会被重复提交）
    --- 书签（get会被收藏，post不可被收藏为书签）
    --- 缓存（幂等）
    --- 传参
    --- 参数长度
    --- 编码类型
    --- 历史
    --- 安全
    --- 可见性
    --- 发送数据（post请求头、请求体）

### 5.http 状态码 301 和 302（2）

### 6.cookie 首部相关字段（1）

    --- size
    --- name
    --- value
    --- domain
    --- path
    --- expires/Max-Age
    --- secure
    --- http-only
    --- samesite

### 7.https 和 http 的区别，https 握手（2）

    ---https是需要ca证书，需要一定费用
    ---http是明文传输，https是具有安全性的ssl加密传输协议
    ---http和https适用于不同的连接方式（端口不同，http的端口为80，https的端口403）
    ---https加密传输，有身份认证，比http协议安全
    --https实现原理⭐⭐⭐⭐⭐
    1.客户端向服务端发起一个随机值，以及一个加密算法
    2.服务端收到后返回一个协商好的加密算法，以及另一个随机值
    3.服务端在发送一个公钥CA
    4.客户端收到以后先验证CA是否有效，如果无效则报错弹窗，有过有效则进行下一步操作
    5.客户端使用之前的两个随机值和一个预主密钥组成一个会话密钥，在通过服务端传来的公钥加密把会话密钥发送给服务端
    6.服务端收到后使用私钥解密，得到两个随机值和预主密钥，然后组装成会话密钥
    7.客户端在向服务端发起一条信息，这条信息使用会话秘钥加密，用来验证服务端时候能收到加密的信息
    8.服务端收到信息后返回一个会话秘钥加密的信息，收到以后SSL层连接建立成功

### 8.中间人攻击(1)

### 9.防范中间人攻击（1）

### 10.web 攻击以及防御（2）

    ---xss攻击
    ---预防
    ---1.对代码做好转义
    ---2.使用csp（http-equiv="Content-Security-Policy）
    ---3.敏感信息保护(http-only)
    ---4.使用验证码

    ---csrf
    ---预防
    ---1.进行同源检测（referer、origin）
    ---2.CSRF TOKEN
    ---3.cookie双重验证
    ---4.Samesite

### 11.浏览器存储（2）

### 12.浏览器的缓存策略（2）

### 13.计算机网络模型以及各层协议（2）

    ---tcp/ip模型（应用层、传输层、网络层、数据链路层、物理层）
    ---osi七层模型（应用层、表示层、会话层、传输层（tcp）、网络层、数据链路层、物理层）

### 14.http 报文结构（1）

    ---请求报文:
    ----1.请求行（http版本号、url、请求方式）、
    ----2.请求头（cache-control、keep-alive、host）
    ----3.空行
    ----4.请求体

    ---响应报文:
    ----1.响应行（版本、状态码、原因）
    ----2.响应头（cache、control、etag、last-modified）
    ----3.空行
    ----4.响应体

### 15.10 项严重的安全风险列表都有那些？（1）

    ---sql注入
    ---失效的身份验证
    ---敏感数据泄露
    ---XML 外部实体
    ---失效的访问控制
    ---安全配置错误
    ---xss
    ---不安全的反序列化
    ---使用含有已知漏洞的组件
    ---不足的日志记录和监控

### 16.什么是 CDN?(1)

### 17.滑动窗口和拥塞窗口的区别？（1）

    ---滑动窗口
    ----发送窗口永远小于或等于接收窗口，发送窗口的大小取决于接收窗口的大小
    ----控制流量来保证TCP的可靠传输（不控制流量的话可能会溢出）
    ---发送方的数据分为
    ----1已发送，接收到ACK的
    ----2已发送，未接收到ACK的
    ----3未发送，但允许发送的
    ----4未发送，但不允许发送的
    ----2和3表示发送窗口
    ---接收方
    ----1.已接收
    ----2.未接受但准备接受
    ----3.未接受不准备接受

    ---拥塞窗口
    ----防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。
    ----是一个全局性的过程
    ----方法
    ----慢开始、拥塞避免、快重传、快恢复

### 18.从浏览器输入 url 后都经历了什么（1）

### 19.http1.0 和 http1.1,还有 2.0 有什么区别？（1）

---

## Vue

### 1.Vue-router 有哪几种钩子（1）

### 2.组件通信的方式（1）

### 3.vue 组件中 key 的作用（1）

### 4.虚拟 dom 的优缺点（1）

### 5.diff 算法（1）

### 6.mvc 和 mvvm 有什么区别（1）

### 7.vue-router 的模式（1）

    ---hash模式
    监听hashchange事件实现前端路由，利用url中的hash来模拟一个hash，以保证url改变时，页面不会重新加载。
    ---history模式
    利用pushstate和replacestate来将url替换但不刷新，但是有一个致命点就是，一旦刷新的话，就会可能404，因为没有当前的真正路径，要想解决这一问题需要后端配合，将不存在的路径重定向到入口文件

### 8.vue 的优化方式（1）

### 9.computed 和 watch 的区别(1)

### 10.vue 中的 nextTick（1）

### 11.vue 中父子组件的生命周期（1）

### 12.vue 的生命周期（1）

### 13.vue 双向绑定（1）

---

## webpack

### 1.loader 和 plugin 的区别（1）

### 2.webpack 常用的几个对象及解释（1）

    ---entry
    ---output
    ---mode
    ---module（loader）
    ---plugin
    ---devServer
    ---resolve（extension、alias）
    ---babel

---

## 规范化

### 1.git 的常用命令（1）

    ---git reset soft head^ (提交后撤回)
    ---git branch xx 创建分支
    ---git checkout xx 切换分支
    添加：
    ---git add. 将修改加入缓存区
    ---git push
    ---git commit -m 备注修改内容

    ---git status 查看当前状态
    ---git checkout . 放弃分支上的修改
    ---git pull
    ---git log

---

## 手写题

### 1. 快排.js（3）

### 2. 防抖.js (3)

### 3. 节流.js (3)

### 4. 深拷贝.js (3)

### 5. 观察者模式.js （1）

### 6. 发布订阅者模块.js （2）

### 7. 数组去重.js (2)

### 8. 数组扁平化.js (2)

### 9. 手写 apply、call、bind（3）

### 10.手写函数柯里化、实现一个 add 方法（3）

### 11.手写 new 函数（3）

    ---首先创建了一个新的空对象
    ---设置原型，将对象的原型设置为函数的 prototype 对象。
    ---让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
    ---判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

### 12.冒泡排序（1）

### 13.插入排序（1）

### 14.是否回文（1）

### 15.正则表达式,千分位分割（1）

### 16.斐波拉契数列（1）

### 17.手写 Promise（1）

### 18.手写instanceof(1)

---
